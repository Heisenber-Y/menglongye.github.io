<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>十大经典排序算法 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="十大经典排序算法动画与解析，看我就够了！（配代码完全版）排序算法是《数据结构与算法》中最基本的算法之一。 [百度链接]（http:&#x2F;&#x2F;www.baidu.com） http:&#x2F;&#x2F;www.bing.com 排序算法可以分为内部排序和外部排序。 内部排序是数据记录在内存中进行排序。 而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 常见的内部排序算法有：插入排序、希">
<meta property="og:type" content="article">
<meta property="og:title" content="十大经典排序算法">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;15&#x2F;%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="十大经典排序算法动画与解析，看我就够了！（配代码完全版）排序算法是《数据结构与算法》中最基本的算法之一。 [百度链接]（http:&#x2F;&#x2F;www.baidu.com） http:&#x2F;&#x2F;www.bing.com 排序算法可以分为内部排序和外部排序。 内部排序是数据记录在内存中进行排序。 而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 常见的内部排序算法有：插入排序、希">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_png&#x2F;D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaKhGcwh6KibXbSiadtHqwgjmmzBYCa2DNuj5Vhw3lHc96z1wge3ZbDAeg&#x2F;640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">
<meta property="og:image" content="https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_gif&#x2F;D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaC1S2jpXRzXcZVn0aP6BYnkO2FJicNstxicHmf9wMIic5FV0I75ptv5jYA&#x2F;640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1">
<meta property="og:image" content="https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_gif&#x2F;D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaB2dW1vA5SganRPChytYTFiaJL2PkXlL7XmhYmqIAzBHj0VvgJZs0vmA&#x2F;640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1">
<meta property="og:image" content="https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_gif&#x2F;D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaiatKZU4exjwcluduiclJOdZB0oZQicCrpIEaSJJg8iaia58viauSK3nhofqA&#x2F;640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1">
<meta property="og:image" content="data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:image" content="data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==">
<meta property="og:updated_time" content="2019-11-15T10:38:42.706Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;mmbiz.qpic.cn&#x2F;mmbiz_png&#x2F;D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaKhGcwh6KibXbSiadtHqwgjmmzBYCa2DNuj5Vhw3lHc96z1wge3ZbDAeg&#x2F;640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-十大经典排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/15/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2019-11-15T10:35:38.000Z" itemprop="datePublished">2019-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      十大经典排序算法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="十大经典排序算法动画与解析，看我就够了！（配代码完全版）"><a href="#十大经典排序算法动画与解析，看我就够了！（配代码完全版）" class="headerlink" title="十大经典排序算法动画与解析，看我就够了！（配代码完全版）"></a>十大经典排序算法动画与解析，看我就够了！（配代码完全版）</h2><p><strong>排序算法是《数据结构与算法》中最基本的算法之一。</strong></p>
<p>[百度链接]（<a href="http://www.baidu.com）" target="_blank" rel="noopener">http://www.baidu.com）</a></p>
<p><a href="http://www.bing.com" target="_blank" rel="noopener">http://www.bing.com</a></p>
<p>排序算法可以分为<strong>内部排序</strong>和<strong>外部排序</strong>。</p>
<p>内部排序是数据记录在内存中进行排序。</p>
<p>而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p>
<p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>
<a id="more"></a>

<p>用一张图概括：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaKhGcwh6KibXbSiadtHqwgjmmzBYCa2DNuj5Vhw3lHc96z1wge3ZbDAeg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="image">时间复杂度与空间复杂度</p>
<h4 id="关于时间复杂度："><a href="#关于时间复杂度：" class="headerlink" title="关于时间复杂度："></a>关于时间复杂度：</h4><ol>
<li>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li>
<li>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</li>
<li>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</li>
<li>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li>
</ol>
<h4 id="关于稳定性："><a href="#关于稳定性：" class="headerlink" title="关于稳定性："></a>关于稳定性：</h4><ol>
<li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</li>
<li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</li>
</ol>
<h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><h4 id="1-1-算法步骤"><a href="#1-1-算法步骤" class="headerlink" title="1.1 算法步骤"></a>1.1 算法步骤</h4><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h4 id="1-2-动画演示"><a href="#1-2-动画演示" class="headerlink" title="1.2 动画演示"></a>1.2 动画演示</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaC1S2jpXRzXcZVn0aP6BYnkO2FJicNstxicHmf9wMIic5FV0I75ptv5jYA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="image">冒泡排序动画演示</p>
<h4 id="1-3-参考代码"><a href="#1-3-参考代码" class="headerlink" title="1.3 参考代码"></a>1.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> 1// Java 代码实现</span><br><span class="line"> 2public class BubbleSort implements IArraySort &#123;</span><br><span class="line"> 3</span><br><span class="line"> 4    @Override</span><br><span class="line"> 5    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 6        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line"> 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> 8</span><br><span class="line"> 9        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">10            // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span><br><span class="line">11            boolean flag = true;</span><br><span class="line">12</span><br><span class="line">13            for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">14                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">15                    int tmp = arr[j];</span><br><span class="line">16                    arr[j] = arr[j + 1];</span><br><span class="line">17                    arr[j + 1] = tmp;</span><br><span class="line">18</span><br><span class="line">19                    flag = false;</span><br><span class="line">20                &#125;</span><br><span class="line">21            &#125;</span><br><span class="line">22</span><br><span class="line">23            if (flag) &#123;</span><br><span class="line">24                break;</span><br><span class="line">25            &#125;</span><br><span class="line">26        &#125;</span><br><span class="line">27        return arr;</span><br><span class="line">28    &#125;</span><br><span class="line">29&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><h4 id="2-1-算法步骤"><a href="#2-1-算法步骤" class="headerlink" title="2.1 算法步骤"></a>2.1 算法步骤</h4><ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<h4 id="2-2-动画演示"><a href="#2-2-动画演示" class="headerlink" title="2.2 动画演示"></a>2.2 动画演示</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaB2dW1vA5SganRPChytYTFiaJL2PkXlL7XmhYmqIAzBHj0VvgJZs0vmA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="image">选择排序动画演示</p>
<h4 id="2-3-参考代码"><a href="#2-3-参考代码" class="headerlink" title="2.3 参考代码"></a>2.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1//Java 代码实现</span><br><span class="line"> 2public class SelectionSort implements IArraySort &#123;</span><br><span class="line"> 3</span><br><span class="line"> 4    @Override</span><br><span class="line"> 5    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> 7</span><br><span class="line"> 8        // 总共要经过 N-1 轮比较</span><br><span class="line"> 9        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">10            int min = i;</span><br><span class="line">11</span><br><span class="line">12            // 每轮需要比较的次数 N-i</span><br><span class="line">13            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">14                if (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">15                    // 记录目前能找到的最小值元素的下标</span><br><span class="line">16                    min = j;</span><br><span class="line">17                &#125;</span><br><span class="line">18            &#125;</span><br><span class="line">19</span><br><span class="line">20            // 将找到的最小值和i位置所在的值进行交换</span><br><span class="line">21            if (i != min) &#123;</span><br><span class="line">22                int tmp = arr[i];</span><br><span class="line">23                arr[i] = arr[min];</span><br><span class="line">24                arr[min] = tmp;</span><br><span class="line">25            &#125;</span><br><span class="line">26</span><br><span class="line">27        &#125;</span><br><span class="line">28        return arr;</span><br><span class="line">29    &#125;</span><br><span class="line">30&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><h4 id="3-1-算法步骤"><a href="#3-1-算法步骤" class="headerlink" title="3.1 算法步骤"></a>3.1 算法步骤</h4><ul>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ul>
<h4 id="3-2-动画演示"><a href="#3-2-动画演示" class="headerlink" title="3.2 动画演示"></a>3.2 动画演示</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaiatKZU4exjwcluduiclJOdZB0oZQicCrpIEaSJJg8iaia58viauSK3nhofqA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="image">插入排序动画演示</p>
<h4 id="3-3-参考代码"><a href="#3-3-参考代码" class="headerlink" title="3.3 参考代码"></a>3.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1//Java 代码实现</span><br><span class="line"> 2public class InsertSort implements IArraySort &#123;</span><br><span class="line"> 3</span><br><span class="line"> 4    @Override</span><br><span class="line"> 5    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 6        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line"> 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> 8</span><br><span class="line"> 9        // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span><br><span class="line">10        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">11</span><br><span class="line">12            // 记录要插入的数据</span><br><span class="line">13            int tmp = arr[i];</span><br><span class="line">14</span><br><span class="line">15            // 从已经排序的序列最右边的开始比较，找到比其小的数</span><br><span class="line">16            int j = i;</span><br><span class="line">17            while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123;</span><br><span class="line">18                arr[j] = arr[j - 1];</span><br><span class="line">19                j--;</span><br><span class="line">20            &#125;</span><br><span class="line">21</span><br><span class="line">22            // 存在比其小的数，插入</span><br><span class="line">23            if (j != i) &#123;</span><br><span class="line">24                arr[j] = tmp;</span><br><span class="line">25            &#125;</span><br><span class="line">26</span><br><span class="line">27        &#125;</span><br><span class="line">28        return arr;</span><br><span class="line">29    &#125;</span><br><span class="line">30&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><h4 id="4-1-算法步骤"><a href="#4-1-算法步骤" class="headerlink" title="4.1 算法步骤"></a>4.1 算法步骤</h4><ul>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h4 id="4-2-动画演示"><a href="#4-2-动画演示" class="headerlink" title="4.2 动画演示"></a>4.2 动画演示</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="image">希尔排序动画演示</p>
<h4 id="4-3-参考代码"><a href="#4-3-参考代码" class="headerlink" title="4.3 参考代码"></a>4.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> 1//Java 代码实现</span><br><span class="line"> 2public class ShellSort implements IArraySort &#123;</span><br><span class="line"> 3</span><br><span class="line"> 4    @Override</span><br><span class="line"> 5    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 6        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line"> 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> 8</span><br><span class="line"> 9        int gap = 1;</span><br><span class="line">10        while (gap &lt; arr.length) &#123;</span><br><span class="line">11            gap = gap * 3 + 1;</span><br><span class="line">12        &#125;</span><br><span class="line">13</span><br><span class="line">14        while (gap &gt; 0) &#123;</span><br><span class="line">15            for (int i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">16                int tmp = arr[i];</span><br><span class="line">17                int j = i - gap;</span><br><span class="line">18                while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) &#123;</span><br><span class="line">19                    arr[j + gap] = arr[j];</span><br><span class="line">20                    j -= gap;</span><br><span class="line">21                &#125;</span><br><span class="line">22                arr[j + gap] = tmp;</span><br><span class="line">23            &#125;</span><br><span class="line">24            gap = (int) Math.floor(gap / 3);</span><br><span class="line">25        &#125;</span><br><span class="line">26</span><br><span class="line">27        return arr;</span><br><span class="line">28    &#125;</span><br><span class="line">29&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><h4 id="5-1-算法步骤"><a href="#5-1-算法步骤" class="headerlink" title="5.1 算法步骤"></a>5.1 算法步骤</h4><ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
<h4 id="5-2-动画演示"><a href="#5-2-动画演示" class="headerlink" title="5.2 动画演示"></a>5.2 动画演示</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="image">归并排序动画演示</p>
<h4 id="5-3-参考代码"><a href="#5-3-参考代码" class="headerlink" title="5.3 参考代码"></a>5.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> 1//Java 代码实现</span><br><span class="line">     public class MergeSort implements IArraySort &#123;</span><br><span class="line"> 2</span><br><span class="line"> 3    @Override</span><br><span class="line"> 4    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 5        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line"> 6        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> 7</span><br><span class="line"> 8        if (arr.length &lt; 2) &#123;</span><br><span class="line"> 9            return arr;</span><br><span class="line">10        &#125;</span><br><span class="line">11        int middle = (int) Math.floor(arr.length / 2);</span><br><span class="line">12</span><br><span class="line">13        int[] left = Arrays.copyOfRange(arr, 0, middle);</span><br><span class="line">14        int[] right = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">15</span><br><span class="line">16        return merge(sort(left), sort(right));</span><br><span class="line">17    &#125;</span><br><span class="line">18</span><br><span class="line">19    protected int[] merge(int[] left, int[] right) &#123;</span><br><span class="line">20        int[] result = new int[left.length + right.length];</span><br><span class="line">21        int i = 0;</span><br><span class="line">22        while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123;</span><br><span class="line">23            if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">24                result[i++] = left[0];</span><br><span class="line">25                left = Arrays.copyOfRange(left, 1, left.length);</span><br><span class="line">26            &#125; else &#123;</span><br><span class="line">27                result[i++] = right[0];</span><br><span class="line">28                right = Arrays.copyOfRange(right, 1, right.length);</span><br><span class="line">29            &#125;</span><br><span class="line">30        &#125;</span><br><span class="line">31</span><br><span class="line">32        while (left.length &gt; 0) &#123;</span><br><span class="line">33            result[i++] = left[0];</span><br><span class="line">34            left = Arrays.copyOfRange(left, 1, left.length);</span><br><span class="line">35        &#125;</span><br><span class="line">36</span><br><span class="line">37        while (right.length &gt; 0) &#123;</span><br><span class="line">38            result[i++] = right[0];</span><br><span class="line">39            right = Arrays.copyOfRange(right, 1, right.length);</span><br><span class="line">40        &#125;</span><br><span class="line">41</span><br><span class="line">42        return result;</span><br><span class="line">43    &#125;</span><br><span class="line">44</span><br><span class="line">45&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><h4 id="6-1-算法步骤"><a href="#6-1-算法步骤" class="headerlink" title="6.1 算法步骤"></a>6.1 算法步骤</h4><ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ul>
<h4 id="6-2-动画演示"><a href="#6-2-动画演示" class="headerlink" title="6.2 动画演示"></a>6.2 动画演示</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="image">快速排序动画演示</p>
<h4 id="6-3-参考代码"><a href="#6-3-参考代码" class="headerlink" title="6.3 参考代码"></a>6.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> 1//Java 代码实现</span><br><span class="line"> 2public class QuickSort implements IArraySort &#123;</span><br><span class="line"> 3</span><br><span class="line"> 4    @Override</span><br><span class="line"> 5    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 6        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line"> 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> 8</span><br><span class="line"> 9        return quickSort(arr, 0, arr.length - 1);</span><br><span class="line">10    &#125;</span><br><span class="line">11</span><br><span class="line">12    private int[] quickSort(int[] arr, int left, int right) &#123;</span><br><span class="line">13        if (left &lt; right) &#123;</span><br><span class="line">14            int partitionIndex = partition(arr, left, right);</span><br><span class="line">15            quickSort(arr, left, partitionIndex - 1);</span><br><span class="line">16            quickSort(arr, partitionIndex + 1, right);</span><br><span class="line">17        &#125;</span><br><span class="line">18        return arr;</span><br><span class="line">19    &#125;</span><br><span class="line">20</span><br><span class="line">21    private int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">22        // 设定基准值（pivot）</span><br><span class="line">23        int pivot = left;</span><br><span class="line">24        int index = pivot + 1;</span><br><span class="line">25        for (int i = index; i &lt;= right; i++) &#123;</span><br><span class="line">26            if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">27                swap(arr, i, index);</span><br><span class="line">28                index++;</span><br><span class="line">29            &#125;</span><br><span class="line">30        &#125;</span><br><span class="line">31        swap(arr, pivot, index - 1);</span><br><span class="line">32        return index - 1;</span><br><span class="line">33    &#125;</span><br><span class="line">34</span><br><span class="line">35    private void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">36        int temp = arr[i];</span><br><span class="line">37        arr[i] = arr[j];</span><br><span class="line">38        arr[j] = temp;</span><br><span class="line">39    &#125;</span><br><span class="line">40</span><br><span class="line">41&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><h4 id="7-1-算法步骤"><a href="#7-1-算法步骤" class="headerlink" title="7.1 算法步骤"></a>7.1 算法步骤</h4><ul>
<li>创建一个堆 H[0……n-1]；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li>
<li>重复步骤 2，直到堆的尺寸为 1。</li>
</ul>
<h4 id="7-2-动画演示"><a href="#7-2-动画演示" class="headerlink" title="7.2 动画演示"></a>7.2 动画演示</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>​                                                                     堆排序动画演示</p>
<h4 id="7-3-参考代码"><a href="#7-3-参考代码" class="headerlink" title="7.3 参考代码"></a>7.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> 1//Java 代码实现</span><br><span class="line"> 2public class HeapSort implements IArraySort &#123;</span><br><span class="line"> 3</span><br><span class="line"> 4    @Override</span><br><span class="line"> 5    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 6        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line"> 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> 8</span><br><span class="line"> 9        int len = arr.length;</span><br><span class="line">10</span><br><span class="line">11        buildMaxHeap(arr, len);</span><br><span class="line">12</span><br><span class="line">13        for (int i = len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">14            swap(arr, 0, i);</span><br><span class="line">15            len--;</span><br><span class="line">16            heapify(arr, 0, len);</span><br><span class="line">17        &#125;</span><br><span class="line">18        return arr;</span><br><span class="line">19    &#125;</span><br><span class="line">20</span><br><span class="line">21    private void buildMaxHeap(int[] arr, int len) &#123;</span><br><span class="line">22        for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123;</span><br><span class="line">23            heapify(arr, i, len);</span><br><span class="line">24        &#125;</span><br><span class="line">25    &#125;</span><br><span class="line">26</span><br><span class="line">27    private void heapify(int[] arr, int i, int len) &#123;</span><br><span class="line">28        int left = 2 * i + 1;</span><br><span class="line">29        int right = 2 * i + 2;</span><br><span class="line">30        int largest = i;</span><br><span class="line">31</span><br><span class="line">32        if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">33            largest = left;</span><br><span class="line">34        &#125;</span><br><span class="line">35</span><br><span class="line">36        if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">37            largest = right;</span><br><span class="line">38        &#125;</span><br><span class="line">39</span><br><span class="line">40        if (largest != i) &#123;</span><br><span class="line">41            swap(arr, i, largest);</span><br><span class="line">42            heapify(arr, largest, len);</span><br><span class="line">43        &#125;</span><br><span class="line">44    &#125;</span><br><span class="line">45</span><br><span class="line">46    private void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">47        int temp = arr[i];</span><br><span class="line">48        arr[i] = arr[j];</span><br><span class="line">49        arr[j] = temp;</span><br><span class="line">50    &#125;</span><br><span class="line">51</span><br><span class="line">52&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><h4 id="8-1-算法步骤"><a href="#8-1-算法步骤" class="headerlink" title="8.1 算法步骤"></a>8.1 算法步骤</h4><ul>
<li>花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</li>
<li>开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</li>
<li>数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</li>
<li>最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</li>
</ul>
<h4 id="8-2-动画演示"><a href="#8-2-动画演示" class="headerlink" title="8.2 动画演示"></a>8.2 动画演示</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="image">计数排序动画演示</p>
<h4 id="8-3-参考代码"><a href="#8-3-参考代码" class="headerlink" title="8.3 参考代码"></a>8.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> 1//Java 代码实现</span><br><span class="line"> 2public class CountingSort implements IArraySort &#123;</span><br><span class="line"> 3</span><br><span class="line"> 4    @Override</span><br><span class="line"> 5    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 6        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line"> 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> 8</span><br><span class="line"> 9        int maxValue = getMaxValue(arr);</span><br><span class="line">10</span><br><span class="line">11        return countingSort(arr, maxValue);</span><br><span class="line">12    &#125;</span><br><span class="line">13</span><br><span class="line">14    private int[] countingSort(int[] arr, int maxValue) &#123;</span><br><span class="line">15        int bucketLen = maxValue + 1;</span><br><span class="line">16        int[] bucket = new int[bucketLen];</span><br><span class="line">17</span><br><span class="line">18        for (int value : arr) &#123;</span><br><span class="line">19            bucket[value]++;</span><br><span class="line">20        &#125;</span><br><span class="line">21</span><br><span class="line">22        int sortedIndex = 0;</span><br><span class="line">23        for (int j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">24            while (bucket[j] &gt; 0) &#123;</span><br><span class="line">25                arr[sortedIndex++] = j;</span><br><span class="line">26                bucket[j]--;</span><br><span class="line">27            &#125;</span><br><span class="line">28        &#125;</span><br><span class="line">29        return arr;</span><br><span class="line">30    &#125;</span><br><span class="line">31</span><br><span class="line">32    private int getMaxValue(int[] arr) &#123;</span><br><span class="line">33        int maxValue = arr[0];</span><br><span class="line">34        for (int value : arr) &#123;</span><br><span class="line">35            if (maxValue &lt; value) &#123;</span><br><span class="line">36                maxValue = value;</span><br><span class="line">37            &#125;</span><br><span class="line">38        &#125;</span><br><span class="line">39        return maxValue;</span><br><span class="line">40    &#125;</span><br><span class="line">41</span><br><span class="line">42&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><h4 id="9-1-算法步骤"><a href="#9-1-算法步骤" class="headerlink" title="9.1 算法步骤"></a>9.1 算法步骤</h4><ul>
<li>设置固定数量的空桶。</li>
<li>把数据放到对应的桶中。</li>
<li>对每个不为空的桶中数据进行排序。</li>
<li>拼接不为空的桶中数据，得到结果</li>
</ul>
<h4 id="9-2-动画演示"><a href="#9-2-动画演示" class="headerlink" title="9.2 动画演示"></a>9.2 动画演示</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>​                                                                         桶排序动画演示</p>
<h4 id="9-3-参考代码"><a href="#9-3-参考代码" class="headerlink" title="9.3 参考代码"></a>9.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> 1//Java 代码实现</span><br><span class="line"> 2public class BucketSort implements IArraySort &#123;</span><br><span class="line"> 3</span><br><span class="line"> 4    private static final InsertSort insertSort = new InsertSort();</span><br><span class="line"> 5</span><br><span class="line"> 6    @Override</span><br><span class="line"> 7    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 8        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line"> 9        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">10</span><br><span class="line">11        return bucketSort(arr, 5);</span><br><span class="line">12    &#125;</span><br><span class="line">13</span><br><span class="line">14    private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123;</span><br><span class="line">15        if (arr.length == 0) &#123;</span><br><span class="line">16            return arr;</span><br><span class="line">17        &#125;</span><br><span class="line">18</span><br><span class="line">19        int minValue = arr[0];</span><br><span class="line">20        int maxValue = arr[0];</span><br><span class="line">21        for (int value : arr) &#123;</span><br><span class="line">22            if (value &lt; minValue) &#123;</span><br><span class="line">23                minValue = value;</span><br><span class="line">24            &#125; else if (value &gt; maxValue) &#123;</span><br><span class="line">25                maxValue = value;</span><br><span class="line">26            &#125;</span><br><span class="line">27        &#125;</span><br><span class="line">28</span><br><span class="line">29        int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;</span><br><span class="line">30        int[][] buckets = new int[bucketCount][0];</span><br><span class="line">31</span><br><span class="line">32        // 利用映射函数将数据分配到各个桶中</span><br><span class="line">33        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">34            int index = (int) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">35            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">36        &#125;</span><br><span class="line">37</span><br><span class="line">38        int arrIndex = 0;</span><br><span class="line">39        for (int[] bucket : buckets) &#123;</span><br><span class="line">40            if (bucket.length &lt;= 0) &#123;</span><br><span class="line">41                continue;</span><br><span class="line">42            &#125;</span><br><span class="line">43            // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">44            bucket = insertSort.sort(bucket);</span><br><span class="line">45            for (int value : bucket) &#123;</span><br><span class="line">46                arr[arrIndex++] = value;</span><br><span class="line">47            &#125;</span><br><span class="line">48        &#125;</span><br><span class="line">49</span><br><span class="line">50        return arr;</span><br><span class="line">51    &#125;</span><br><span class="line">52</span><br><span class="line">53    /**</span><br><span class="line">54     * 自动扩容，并保存数据</span><br><span class="line">55     *</span><br><span class="line">56     * @param arr</span><br><span class="line">57     * @param value</span><br><span class="line">58     */</span><br><span class="line">59    private int[] arrAppend(int[] arr, int value) &#123;</span><br><span class="line">60        arr = Arrays.copyOf(arr, arr.length + 1);</span><br><span class="line">61        arr[arr.length - 1] = value;</span><br><span class="line">62        return arr;</span><br><span class="line">63    &#125;</span><br><span class="line">64</span><br><span class="line">65&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><h4 id="10-1-算法步骤"><a href="#10-1-算法步骤" class="headerlink" title="10.1 算法步骤"></a>10.1 算法步骤</h4><ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</li>
<li>从最低位开始，依次进行一次排序</li>
<li>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li>
</ul>
<h4 id="10-2-动画演示"><a href="#10-2-动画演示" class="headerlink" title="10.2 动画演示"></a>10.2 动画演示</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>​                                                                        基数排序动画演示</p>
<h4 id="10-3-参考代码"><a href="#10-3-参考代码" class="headerlink" title="10.3 参考代码"></a>10.3 参考代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> 1//Java 代码实现</span><br><span class="line"> 2public class RadixSort implements IArraySort &#123;</span><br><span class="line"> 3</span><br><span class="line"> 4    @Override</span><br><span class="line"> 5    public int[] sort(int[] sourceArray) throws Exception &#123;</span><br><span class="line"> 6        // 对 arr 进行拷贝，不改变参数内容</span><br><span class="line"> 7        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"> 8</span><br><span class="line"> 9        int maxDigit = getMaxDigit(arr);</span><br><span class="line">10        return radixSort(arr, maxDigit);</span><br><span class="line">11    &#125;</span><br><span class="line">12</span><br><span class="line">13    /**</span><br><span class="line">14     * 获取最高位数</span><br><span class="line">15     */</span><br><span class="line">16    private int getMaxDigit(int[] arr) &#123;</span><br><span class="line">17        int maxValue = getMaxValue(arr);</span><br><span class="line">18        return getNumLenght(maxValue);</span><br><span class="line">19    &#125;</span><br><span class="line">20</span><br><span class="line">21    private int getMaxValue(int[] arr) &#123;</span><br><span class="line">22        int maxValue = arr[0];</span><br><span class="line">23        for (int value : arr) &#123;</span><br><span class="line">24            if (maxValue &lt; value) &#123;</span><br><span class="line">25                maxValue = value;</span><br><span class="line">26            &#125;</span><br><span class="line">27        &#125;</span><br><span class="line">28        return maxValue;</span><br><span class="line">29    &#125;</span><br><span class="line">30</span><br><span class="line">31    protected int getNumLenght(long num) &#123;</span><br><span class="line">32        if (num == 0) &#123;</span><br><span class="line">33            return 1;</span><br><span class="line">34        &#125;</span><br><span class="line">35        int lenght = 0;</span><br><span class="line">36        for (long temp = num; temp != 0; temp /= 10) &#123;</span><br><span class="line">37            lenght++;</span><br><span class="line">38        &#125;</span><br><span class="line">39        return lenght;</span><br><span class="line">40    &#125;</span><br><span class="line">41</span><br><span class="line">42    private int[] radixSort(int[] arr, int maxDigit) &#123;</span><br><span class="line">43        int mod = 10;</span><br><span class="line">44        int dev = 1;</span><br><span class="line">45</span><br><span class="line">46        for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">47            // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span><br><span class="line">48            int[][] counter = new int[mod * 2][0];</span><br><span class="line">49</span><br><span class="line">50            for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">51                int bucket = ((arr[j] % mod) / dev) + mod;</span><br><span class="line">52                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">53            &#125;</span><br><span class="line">54</span><br><span class="line">55            int pos = 0;</span><br><span class="line">56            for (int[] bucket : counter) &#123;</span><br><span class="line">57                for (int value : bucket) &#123;</span><br><span class="line">58                    arr[pos++] = value;</span><br><span class="line">59                &#125;</span><br><span class="line">60            &#125;</span><br><span class="line">61        &#125;</span><br><span class="line">62</span><br><span class="line">63        return arr;</span><br><span class="line">64    &#125;</span><br><span class="line">65    private int[] arrayAppend(int[] arr, int value) &#123;</span><br><span class="line">66        arr = Arrays.copyOf(arr, arr.length + 1);</span><br><span class="line">67        arr[arr.length - 1] = value;</span><br><span class="line">68        return arr;</span><br><span class="line">69    &#125;</span><br><span class="line">70&#125;</span><br></pre></td></tr></table></figure>

<p>本文思路来源于：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p>
<p>十大经典排序动画详细解析</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483905&idx=1&sn=79512c5e81bc2e8e3095c6ff592e8ed2&chksm=fa0e6d80cd79e496c5cf885d6f5eb5808f47368f855d3f7745d0d407ae22a56d8666eb57b42f&scene=21#wechat_redirect" target="_blank" rel="noopener">┣ 【图解数据结构】一组动画彻底理解冒泡排序</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483943&idx=1&sn=5a9a40a9194fdd2eb82820fe4c4e1df3&chksm=fa0e6da6cd79e4b08768133a793077bf3b55e83141fbd10d69e7723bb95722852733945af58e&scene=21#wechat_redirect" target="_blank" rel="noopener">┣ 【图解数据结构】一组动画彻底理解选择排序</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483979&idx=1&sn=b8154f94771a7509f44139e667a2ef84&chksm=fa0e6dcacd79e4dc2645c05720b73d86ca33de41b52ba03e7c9645a02fe9cca919001d612e58&scene=21#wechat_redirect" target="_blank" rel="noopener">┣ 【图解数据结构】一组动画彻底理解插入排序</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483989&idx=1&sn=0b218fa5f66ee26438dd0dd5e19a49b2&chksm=fa0e6dd4cd79e4c2e112063e2483f88cfeab7765b41216df8bd9d175ef4a38b0b3ed4b59d667&scene=21#wechat_redirect" target="_blank" rel="noopener">┣ 【图解数据结构】一组动画彻底理解希尔排序</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483936&idx=1&sn=c2200cfc66dab87070307badd78beb7a&chksm=fa0e6da1cd79e4b71ab92d6f57713bef20857bdcf185f980155bc4e499ba4d0678b921813819&scene=21#wechat_redirect" target="_blank" rel="noopener">┣ 【图解数据结构】一组动画彻底理解归并排序</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247483963&idx=1&sn=dd58fafb86a43eec3dcdc2a2def8fcb7&chksm=fa0e6dbacd79e4ac5dbf7f507264d2b5a4ecc9e78babbce9917b2e08ac05f5434c697839f46a&scene=21#wechat_redirect" target="_blank" rel="noopener">┣ 【图解数据结构】一组动画彻底理解快速排序</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484004&idx=1&sn=ecbafdec3c38ac7a13979aace18569e4&chksm=fa0e6de5cd79e4f3b059d507ac0c6bf9ec916711891f0e92377f0d4bcf9d24319d09ed68d990&scene=21#wechat_redirect" target="_blank" rel="noopener">┣ 【图解数据结构】一组动画彻底理解堆排序</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484043&idx=1&sn=3743a5e3f79fba00ca794704e0c5a1ba&chksm=fa0e6d0acd79e41c1fbbbc976b1ec390cc9345252984914abd662454675aa7dcaf49c3e125e1&scene=21#wechat_redirect" target="_blank" rel="noopener">┣ 【图解数据结构】一组动画彻底理解计数排序</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484058&idx=1&sn=a7aa08a7decbba40d8af7b3c6a62cf5a&chksm=fa0e6d1bcd79e40d6ec21c64efb2115b3ffa51b3128814e0702f35682b7c85e4c5edb03e3ad1&scene=21#wechat_redirect" target="_blank" rel="noopener">┣ 【图解数据结构】一组动画彻底理解桶排序</a></p>
<p>┣ 【图解数据结构】<a href="http://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247484076&idx=1&sn=fb551e1eb83cd483c7a963cbc432e4bd&chksm=fa0e6d2dcd79e43bc4387b3fd89c61dcc084a4e7396c453d9194f0ae357f1cf725eabd39ebb9&scene=21#wechat_redirect" target="_blank" rel="noopener">一组动画彻底理解基数排序</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/15/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="ck3020nxh0003l4ujc6nl2jgr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/11/15/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          深入学习二叉树
        
      </div>
    </a>
  
  
    <a href="/2019/11/15/my-first-blog/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">my-first-blog</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/15/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">深入学习二叉树</a>
          </li>
        
          <li>
            <a href="/2019/11/15/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大经典排序算法</a>
          </li>
        
          <li>
            <a href="/2019/11/15/my-first-blog/">my-first-blog</a>
          </li>
        
          <li>
            <a href="/2019/11/15/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>